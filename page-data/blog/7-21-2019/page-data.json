{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/7-21-2019","webpackCompilationHash":"a722061ce0656b420fcf","result":{"data":{"markdownRemark":{"html":"<h2>Nick Parlante</h2>\n<p>This blog is first and foremost a tribute to Nick Parlante, whose articles on pointers and linked-lists I have found tremendously helpful as I continue on this path of programming.</p>\n<h2>Arrays in C</h2>\n<p>As someone whose experience is primarily in JavaScript and Python, resizing an array is not something I ever needed to worry about. </p>\n<p>If I add an element to a list (array) in Python or an array in JS, I can do so without worrying that the array in question will have enough space for these new items. In Python and JS, lists and arrays will resize themselves automatically based on need, however the same can't be said for languages like C.  </p>\n<p>In C, you need to say, \"I need an array of size <em>n</em> of <em>this</em> type.\" Something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> charArr<span class=\"token punctuation\">[</span><span class=\"token number\">14</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>For example, say the above code is part of a function somewhere in your program. At compile time, C knows you will have a <em>char</em> array of size 14 and an <em>int</em> matrix (or 2-D array) of size 2500. C will take this information and allocate memory for these arrays in what is known as the <em>stack.</em> The stack is a part of your computer's memory where functions and variables live. Items placed in the stack are temporary, since they only exist for the duration of a function and are then destroyed. Consequently, when a function returns and its local variables are destroyed, the memory being used by those variables is freed up, meaning it can be used for other stuff. </p>\n<p>In a moment, we will see how the <em>stack</em> differs from another piece of your computer's memory known as the <em>heap,</em> though for now simply understand that the heap needs help and the stack got your back; that is, the programmer needs to explicitly declare what the heap should do with memory and when, whereas data in the stack is managed automatically by C.</p>\n<h3>Arrays in Memory</h3>\n<p>What is happening when memory is allocated in the stack for our arrays?</p>\n<p>C designates in the stack <strong>a contiguous block of memory</strong> for each array. To understand why an array uses a contiguous block of memory, let's review how memory is represented in a computer.</p>\n<p>Your computer's memory is a contiguous (someone get me a thesaurus!) sequence of bytes, each of which has its own address. These addresses are integers that range from 0 to the size of your memory (e.g., 8GB) and are in order, i.e., 1, 2, 3, ... <em>n</em> where <em>n</em> is the size of your memory. These addresses are important because it's where your data (or technically <a href=\"https://en.wikipedia.org/wiki/Word_(computer_architecture)\">words</a>) lives, so let's see how an array makes use of them.</p>\n<p>In C a <em>char</em> is one byte, thus a <em>char</em> array of size 14 is 14 bytes. Let's say the first element in this array is at memory address 1. Since the data in our memory is contiguous and we know the size of our data-type (i.e., a char is 1 byte in memory) we know the next element is at address 2. Let's put this idea into in an equation.</p>\n<p>Let <em>B</em> be our <strong>base address</strong>. For all of our arrays, the base address, <em>B</em>, will be the address of our first element. Let <em>c</em> be a contsant that represents how big of a step over our next piece of data is — we'll call this the <strong>stride</strong>. The stride will be the size of our data-type. For example, our stride with a <em>char</em> array is 1 byte, whereas with an <em>int</em> array it would be 4. Last, <em>i</em> is our index. Given this information, we can say:</p>\n<div style=\"text-align:center;\">\n<p><strong>address of element in array = B + c * i</strong></p>\n</div>\n<p>This is why arrays start indexing at 0, because <em>B</em> + (0 * 1 byte) = <em>B</em>, i.e., the first element of an array.</p>\n<p>What is our runtime of accessing an indexed element? Well our equation has one addition and one multiplication — two constant time procedures. Therefore indexing an array costs constant time.</p>\n<h3>Array Drawbacks</h3>\n<p>So constant runtime when indexing an array of any size is obviously very nice, but we only get this functionality because we predetermined the size of the array.</p>\n<p>Though what if our array requires more space than we allocated at compile time? We could provide extra space in the array by making it bigger than we anticipate our needs to be, but then the stack will allocate memory that will never be used and that's poor use of resources. Also with this approach, theoretically, your array can still overflow.</p>\n<p>Another approach would be to create a new array that is twice the size of the current array, then copy the elements from the current array to the new, larger array. But the copying of elements would take constant time and you still have the issue of allocating more memory than necessary. </p>\n<p>This is where <em>linked-lists</em> provide an alternative. With linked-lists, we can construct a connected sequence of elements using  <strong>dynamic memory allocation,</strong> and thus never encounter the issue of running out of space in our data-structure. </p>\n<h2>Linked-Lists</h2>\n<h3>It's About the Address</h3>\n<p>Earlier I mentioned how the <strong>stack got your back, but the heap needs help.</strong> In order to implement dynamic-memory, the programmer needs to explicitly allocate and deallocate the heap's memory based on need — a common data-structure for this procedure is called a <em>linked-list</em> (For this post, a <em>linked-list</em> refers to a <em>singly linked-list</em>).</p>\n<p>Before we get into code, let's get a picture of what a linked-list is doing. Let's say we have two values of type <code class=\"language-text\">int</code> we want to store, <code class=\"language-text\">1</code> and <code class=\"language-text\">2</code>. We already know that if we put these values in an array, since there are only two, their addresses will make them neighbors in memory. We also know that because elements in an array are part of a contiguous block of memory, any element in an array can be indexed in constant time. Remember, indexing is about finding the memory address of a particular value in an array. </p>\n<p>Then a linked-list comes a long and sees what really makes an array useful is knowing where the <em>address</em> of an element is in constant time. Knowing this, it says forget this contiguous memory stuff, I'm just going to keep track of these addresses, wherever they may be in memory.</p>\n<p>So really a linked-list is a data-structure that will create <strong>a relationship between memory addresses when the memory is not contiguous</strong>. To understand how it does this, we need know about <em>nodes</em>. </p>\n<!-- To understand linked-lists, we need to think like a computer. For example, with array `[1,2]` both values being in the same array, we as the human understand them to be connected in some abstract way. Perhaps these values are scores on a game or guesses for a number; either way, we understand their connection at a high-level, i.e., in terms of their use, but this won't help us understand why a linked-list is so useful. To understand linked-lists, we need to ask: *how does the computer understand their relationship?* If we were to forget about the word array for a moment and look at the data at a low-level, what really connects these two values is their relationship in memory, and more specifically the relationship of their addresses in memory &mdash; we know where the next value is because it starts where the previous element ends. -->\n<h3>Hello, Node!</h3>\n<p>So we still have our values of type int, <code class=\"language-text\">1</code> and <code class=\"language-text\">2</code>, and we want to connect them in some way. We now understand that what we really need is someway of knowing the address of an element we want to connect to, i.,e. we are at value <code class=\"language-text\">1</code> and want to connect to <code class=\"language-text\">2</code>. What if we could develop a data-structure that contains our value, e.g., <code class=\"language-text\">1</code>, and the memory address of wherever <code class=\"language-text\">2</code> is — this is a <em>node</em>.</p>\n<p>A node is comprised of two parts:</p>\n<ul>\n<li>a value (e.g., int, char, etc.)</li>\n<li>a reference to a memory address called <em>next</em></li>\n</ul>\n<p>If there isn't another value to reference, then <em>next</em> will point to <code class=\"language-text\">NULL</code>.</p>\n<p>This is what a node looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> someValue<span class=\"token punctuation\">,</span>\n  next<span class=\"token punctuation\">:</span> addressOrNull\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now we can see a way to connect our two values. In our first node we will store <code class=\"language-text\">1</code> and an address to where <code class=\"language-text\">2</code> is and our second node will contain <code class=\"language-text\">2</code> and its <code class=\"language-text\">next</code> will point to <code class=\"language-text\">NULL,</code> since we only have two nodes in this case. But what if we did want to add another value, and thus another node? Well, we can tell the new node's next to point to the first node, i.e., the one containing <code class=\"language-text\">1</code>, and then we're done.</p>\n<p>It would just be nice to know where this connection of nodes starts, so let's call our leading node <em>head.</em> The head is important because we need it to access every node in our list. In other words, a linked-list only points to <code class=\"language-text\">next</code> not <code class=\"language-text\">prev</code>, so it can't go back. (That's a doubly-linked list, and is beyond the scope of this post.) So if we access the middle node as a starting point to find a value, half of our list is lost in memory!</p>\n<p>And that is a linked-list: a collection of nodes where the first node is called head and the last node's next points to <code class=\"language-text\">NULL</code>. Every node in between these two will contain an address to another node. This address will tell us where exactly the next node is in memory, thus allowing access to the next node in constant time.</p>\n<h2>Memory Allocation</h2>\n<p>Now you're probably wondering, \"What about all that talk of the programmer allocating memory in the heap?\" </p>\n<p>I am glad you asked. Now we will return to some C code to understand how a program will implement a linked-list.</p>\n<p>First, let's see what a node looks like in C:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>That <code class=\"language-text\">*</code> after node is saying that <code class=\"language-text\">next</code> isn't a node itself, but rather a memory address for another node — let's call this a <strong>pointer</strong>. Why a pointer? Becuase we only have the address of the node, not the node itself. The address <em>points</em> us to the where the node is in memory, thus the name pointer.</p>\n<p>Let's take a look at some code from Nick Parlante's <a href=\"http://cslibrary.stanford.edu/103/LinkedListBasics.pdf\">Linked Lists Basics</a>, then we will break it down.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> <span class=\"token function\">BuildOneTwoThree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> head <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> second <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> third <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  \n  head <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  second <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  third <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  head<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n  head<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> second<span class=\"token punctuation\">;</span>\n\n  second<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n  second<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> third<span class=\"token punctuation\">;</span>\n\n  third<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> \n  third<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>  \n\n  <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3><code class=\"language-text\">struct node* head = NULL;</code></h3>\n<p>With <code class=\"language-text\">struct node* head = NULL</code>, we are declaring our first node pointer named <code class=\"language-text\">head</code>. It is <strong>very</strong> important to know that when we declare a pointer, it does not have a memory address to point to yet. If we were to try and assign a value to <code class=\"language-text\">head</code> at this point, we would get a <em>Segmentation Fault</em> error in our program, because there is no where in memory for our value to go.</p>\n<p>Think of the memory address as a container that holds your data. At this point, we have not assigned <code class=\"language-text\">head</code> a container.</p>\n<p>Thus before we can start using a node, we need to allocate memory for it. This is where <code class=\"language-text\">malloc</code> comes in.</p>\n<h3><code class=\"language-text\">malloc</code></h3>\n<p><code class=\"language-text\">malloc</code> is used to allocate memory on the heap. When we call <code class=\"language-text\">head = malloc(sizeof(struct node))</code>, we are giving the orders, \"<em>head</em>, here is your memory address. <em>malloc</em>, create a space in memory for <em>head</em> the size of <em>struct node</em> at the address given to <em>head</em>.\"</p>\n<p>Now we can fill our nodes with some data since there is a place in memory for that data to go.</p>\n<h3>Dereferencing</h3>\n<p>Lets give our nodes some data. In C, if a pointer is a <code class=\"language-text\">struct</code> (think <code class=\"language-text\">dict</code> in Python, or <code class=\"language-text\">Object</code> in JavaScript), its members are accessed via the arrow operater (<code class=\"language-text\">-&gt;</code>) — this is known as <strong>dereferencing</strong>. </p>\n<p>Dereferencing is the process of accessing the memory your pointer has the address to. If we were to try and deference a node, i.e., <code class=\"language-text\">head-&gt;data = 1</code> where <code class=\"language-text\">head</code> is a node pointer, before <code class=\"language-text\">head = malloc(sizeof(struct node))</code> allocates memory on the heap for the node, we just dereferenced a bad pointer (which is bad)! Deferencing a bad pointer is when you try and put some data in your pointer's reference before creating that reference.</p>\n<p>So we allocated memory for our pointers and provided them data, but what happens when we're done with the data? We know the stack automatically destroys variables when a function exits, but that's not the case when using the heap. With the heap, we need to <em>free</em> up that memory once we are done with it. </p>\n<h3><code class=\"language-text\">free</code></h3>\n<p>Once you are done with your pointer, you need to free up the memory it was using. Of course, if you do this before you finish using the values being referenced in your pointers, well, you won't be able to use those values anymore. Consider the following code that frees up the memory used by nodes in the linked-list returned by <code class=\"language-text\">BuildOneTwoThree</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Creates a pointer to head, i.e., the first node</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> LinkedList <span class=\"token operator\">=</span> <span class=\"token function\">BuildOneTwoThree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> currNode<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>currNode <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  currNode <span class=\"token operator\">=</span> LinkedList<span class=\"token punctuation\">;</span>\n  LinkedList <span class=\"token operator\">=</span> LinkedList<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>currNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This code will free every node until we reach NULL, indicating there are no more items in the list.</p>\n<h2>Linked-Lists Drawbacks</h2>\n<p>So we clearly see how linked-lists win in the memory allocation debate, though how do they fair in terms of time complexity?\nIn particular, we are concerned with the worst case runtime of accessing an element in a linked-list. </p>\n<p>With arrays we saw that indexing any element is a constant time procedure, though with linked-lists our Big O of accessing an element is linear-time. This is because the worst-case scenario is having the element of interest be in the last node of the linked-list, thus meaning we need to traverse the entire linked-list to get our value. </p>\n<h2>Conclusion</h2>\n<p>I really enjoyed learning about linked-lists and C in general. C has something that always seemed so enigmatic to me, namely because of all the horror stories I read of people claiming how difficult pointers are. Thankfully someone responded to one of these posts with a link to Nick Parlante's computer science resources:</p>\n<ul>\n<li><a href=\"http://cslibrary.stanford.edu/\">Stanford CS Education Library</a></li>\n</ul>\n<!-- \nIn programs like C you need to allocate the size of an array at compile time, meaning it can not be modified at runtime. This causes some problems in that your array may overflow. One solution to this drawback is implementing a linked-list. A linked-list is connected sequence of n -->","frontmatter":{"date":"July 21, 2019","path":"/blog/7-21-2019","title":"Let's Talk Linked-Lists","info":"Memory allocation, pointers, linked-lists in C. A tribute to Nick Parlante."}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}